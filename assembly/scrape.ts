import { http } from "@hypermode/modus-sdk-as";
import { generateText } from "./index"; // Import the generateText function

@json
class ScrapedContent {
  @alias("text")
  quote!: string;
}

/**
 * Scrape content from a URL
 * @param url The URL to scrape content from
 * @returns The raw scraped content (quote)
 */
export function getScrapedContent(url: string): ScrapedContent {
  const scrapeRequest = new http.Request(`http://localhost:5000/webscrape?url=${url}`);

  const scrapeResponse = http.fetch(scrapeRequest);
  if (!scrapeResponse.ok) {
    throw new Error(
      `Failed to scrape content. Received: ${scrapeResponse.status} ${scrapeResponse.statusText}`
    );
  }

  return {
    quote: "Scraping completed." 
  };
}

/**
 * Query the LLM based on the latest scraped content and the user's question
 * @param query The user's question to ask the LLM
 * @returns The answer generated by the LLM based on the scraped content and the user's question
 */
export function queryLLMWithScrapedContent(query: string): string {
  // Fetch the latest scraped content
  const request = new http.Request(`http://localhost:5000/get-scraped-text`);
  
  const response = http.fetch(request);
  if (!response.ok) {
    throw new Error(
      `Failed to fetch scraped content. Received: ${response.status} ${response.statusText}`
    );
  }

  const scrapedContents = response.json<ScrapedContent[]>();
  const scrapedText = scrapedContents[scrapedContents.length - 1].quote;

  // Now generate an answer based on the scraped text and the user's query
  const prompt = `Answer the following question based on the provided context: ${scrapedText}\nUser question: ${query}`;

  // Call the generateText function to generate an answer based on the context and the user's query
  const answer = generateText("Answer based on context", prompt);

  return answer; 
}
